<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Ref Navigator Pro</title>
  <style>
    :root { --bg: #000000; --ui-bg: rgba(20,20,20,0.9); --accent: #4a90e2; }
    
    body {
      margin: 0; padding: 0; background: var(--bg); color: #fff;
      font-family: system-ui, sans-serif;
      height: 100vh; width: 100vw; overflow: hidden;
      user-select: none; -webkit-user-select: none;
    }

    /* --- CANVAS / IMAGE --- */
    .viewport {
      position: absolute; top: 0; left: 0;
      width: 100vw; height: 100vh;
      display: flex; align-items: center; justify-content: center;
      touch-action: none; /* Prevents browser scroll */
      z-index: 1;
    }

    #mainImage {
      width: 100%; height: 100%;
      object-fit: contain; /* Maximize size without distortion */
      will-change: transform;
      cursor: grab;
    }
    #mainImage:active { cursor: grabbing; }

    /* --- UI LAYOUT --- */
    .ui-layer {
      position: fixed; z-index: 100;
      display: flex; pointer-events: none;
    }
    .ui-layer > * { pointer-events: auto; }

    /* Top Center: Search & Categories */
    .top-center {
      top: 10px; left: 50%; transform: translateX(-50%);
      flex-direction: column; align-items: center; gap: 8px;
      width: auto; max-width: 95vw;
    }

    .search-box {
      background: var(--ui-bg); border: 1px solid #444; color: #fff;
      padding: 6px 12px; border-radius: 20px; font-size: 14px;
      width: 160px; text-align: center; outline: none;
      backdrop-filter: blur(5px);
    }

    /* Fixed the "Huge UI" bug: Used Flex instead of Grid */
    .category-container {
      display: flex; flex-wrap: wrap; justify-content: center; gap: 4px;
      background: var(--ui-bg); padding: 5px; border-radius: 10px;
      backdrop-filter: blur(5px);
      max-width: 100%;
    }

    .cat-btn {
      width: 30px; height: 30px; /* Force small square size */
      display: flex; align-items: center; justify-content: center;
      background: #333; border-radius: 5px; cursor: pointer;
      font-size: 12px; font-weight: bold; color: #aaa;
      transition: all 0.1s;
    }
    .cat-btn input { display: none; }
    /* Checkbox Logic: The label is the button */
    .cat-btn:has(input:checked) {
      background: var(--accent); color: #fff; box-shadow: 0 0 8px var(--accent);
    }

    /* Navigation Buttons */
    .side-nav {
      top: 50%; width: 100%; transform: translateY(-50%);
      justify-content: space-between; padding: 0 10px; box-sizing: border-box;
      pointer-events: none;
    }
    .nav-btn {
      pointer-events: auto;
      background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1);
      color: white; font-size: 24px; padding: 15px 10px;
      border-radius: 8px; cursor: pointer; transition: background 0.2s;
    }
    .nav-btn:hover { background: rgba(50,50,50,0.8); }
    .nav-btn:disabled { opacity: 0.2; cursor: default; }

    /* Bottom Tools */
    .bottom-bar {
      bottom: 20px; left: 50%; transform: translateX(-50%);
      gap: 15px; background: var(--ui-bg); padding: 8px 15px; border-radius: 20px;
    }
    .tool-btn {
      background: transparent; border: none; color: #ccc;
      font-size: 18px; cursor: pointer; padding: 0 5px;
    }
    .tool-btn:hover { color: #fff; transform: scale(1.1); }

    /* Hiding & Loading */
    .hidden-ui .ui-layer { display: none !important; }
    
    #loader {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.8); padding: 8px 16px; border-radius: 12px;
      font-size: 12px; letter-spacing: 1px; pointer-events: none; display: none;
    }
  </style>
</head>
<body>

<div class="ui-layer top-center">
  <input type="text" id="searchInput" class="search-box" placeholder="Search #tag">
  <div id="catWrapper" class="category-container">
    </div>
</div>

<div class="viewport">
  <img id="mainImage" draggable="false" />
</div>
<div id="loader">LOADING</div>

<div class="ui-layer side-nav">
  <button id="backBtn" class="nav-btn">‚ùÆ</button>
  <button id="fwdBtn" class="nav-btn">‚ùØ</button>
</div>

<div class="ui-layer bottom-bar">
  <button id="resetBtn" class="tool-btn" title="Reset (R)">‚Üª</button>
  <button id="flipBtn" class="tool-btn" title="Flip (F)">‚Üî</button>
  <button id="copyBtn" class="tool-btn" title="Copy">üìã</button>
  <button id="uiBtn" class="tool-btn" title="Toggle UI (U)">üëÅ</button>
</div>

<script>
  // --- CONFIG ---
  const baseURL = 'https://f003.backblazeb2.com/file/linksref2/';
  const categories = [
    {v:"People",l:"P"},{v:"pplus",l:"p"},{v:"Anime",l:"A"},{v:"angle",l:"a"},{v:"Figure",l:"F"},{v:"Style",l:"S"},
    {v:"XMaleAnatomy",l:"X"},{v:"Emotions",l:"E"},{v:"Background",l:"B"},{v:"Walk",l:"W"},{v:"screencap",l:"s"},{v:"Manga",l:"M"},
    {v:"moeManga",l:"m"},{v:"TestPanel",l:"T"}
  ];
  
  // --- STATE ---
  const state = {
    sources: {},       // Cache for text files
    backStack: [],     // History
    forwardStack: [],  // Redo history
    preloadQueue: [],  // Future random buffer
    currentUrl: null,
    transform: { x:0, y:0, scale:1, flipped:false },
    isDragging: false,
    dragStart: { x:0, y:0 }
  };

  // --- ELEMENTS ---
  const el = {
    img: document.getElementById('mainImage'),
    cats: document.getElementById('catWrapper'),
    search: document.getElementById('searchInput'),
    loader: document.getElementById('loader'),
    btnBack: document.getElementById('backBtn'),
    btnFwd: document.getElementById('fwdBtn')
  };

  // --- INIT ---
  function init() {
    // 1. Build Categories
    categories.forEach(cat => {
      const label = document.createElement('label');
      label.className = 'cat-btn';
      label.innerHTML = `<input type="checkbox" value="${cat.v}">${cat.l}`;
      el.cats.appendChild(label);
    });
    
    // Select first by default
    const first = el.cats.querySelector('input');
    if(first) first.checked = true;

    // 2. Bind Events
    bindControls();
    
    // 3. Initial Load
    fullRefresh(); 
  }

  // --- LOGIC ---

  // Called when Category or Search changes
  async function fullRefresh() {
    // WIPE EVERYTHING
    state.backStack = [];
    state.forwardStack = [];
    state.preloadQueue = [];
    state.currentUrl = null;
    
    updateNavButtons();
    
    await fetchSelectedSources();
    navigateForward(true); // true = force new image
  }

  async function fetchSelectedSources() {
    const active = [...el.cats.querySelectorAll('input:checked')].map(i => i.value);
    
    const jobs = active.map(async key => {
      if(!state.sources[key]) {
        try {
          const r = await fetch(baseURL + key + '.txt');
          if(!r.ok) throw new Error('404');
          const txt = await r.text();
          state.sources[key] = txt.split('\n').filter(x => x.trim().length > 5);
        } catch(e) { state.sources[key] = []; }
      }
    });
    await Promise.all(jobs);
    fillQueue();
  }

  function getPool() {
    const active = [...el.cats.querySelectorAll('input:checked')].map(i => i.value);
    const term = el.search.value.toLowerCase().trim();
    let pool = [];
    
    active.forEach(k => { if(state.sources[k]) pool.push(...state.sources[k]); });
    
    if(term) {
      const tags = term.split('#').filter(Boolean);
      if(tags.length) pool = pool.filter(u => tags.some(t => u.toLowerCase().includes(t)));
      else pool = pool.filter(u => u.toLowerCase().includes(term));
    }
    return pool;
  }

  function fillQueue() {
    const pool = getPool();
    if(!pool.length) return;
    
    // Fill up to 8
    while(state.preloadQueue.length < 8) {
      const url = pool[Math.floor(Math.random() * pool.length)];
      // Background load image into browser cache
      new Image().src = url; 
      state.preloadQueue.push(url);
    }
    updateNavButtons();
  }

  function navigateForward(forceNew = false) {
    let next = null;

    // 1. Try Forward History (Redo)
    if(!forceNew && state.forwardStack.length > 0) {
      if(state.currentUrl) pushHistory(state.currentUrl);
      next = state.forwardStack.shift();
    }
    // 2. Try Random Queue
    else if(state.preloadQueue.length > 0) {
      if(state.currentUrl) pushHistory(state.currentUrl);
      next = state.preloadQueue.shift();
      fillQueue();
    }
    // 3. Fallback (Queue empty?)
    else {
      const pool = getPool();
      if(pool.length) next = pool[Math.floor(Math.random() * pool.length)];
    }

    if(next) showImage(next);
  }

  function navigateBack() {
    if(state.backStack.length === 0) return;
    
    if(state.currentUrl) {
      state.forwardStack.unshift(state.currentUrl);
      if(state.forwardStack.length > 5) state.forwardStack.pop();
    }
    
    const prev = state.backStack.pop();
    showImage(prev);
  }

  function pushHistory(url) {
    state.backStack.push(url);
    if(state.backStack.length > 5) state.backStack.shift();
  }

  function showImage(url) {
    state.currentUrl = url;
    el.loader.style.display = 'block';
    el.img.style.opacity = '0.5';

    const i = new Image();
    i.onload = () => {
      el.img.src = url;
      el.img.style.opacity = '1';
      el.loader.style.display = 'none';
      resetTransform();
      updateNavButtons();
    };
    i.onerror = () => {
      console.log('Dead link, skipping');
      navigateForward(true); // Auto-skip
    };
    i.src = url;
  }

  function updateNavButtons() {
    el.btnBack.disabled = (state.backStack.length === 0);
    // Can always go forward unless literally 0 images exist in selection
    el.btnFwd.disabled = (state.forwardStack.length === 0 && state.preloadQueue.length === 0 && getPool().length === 0);
  }

  // --- TRANSFORMS ---
  function applyTransform() {
    const {x, y, scale, flipped} = state.transform;
    const f = flipped ? -1 : 1;
    el.img.style.transform = `translate(${x}px, ${y}px) scale(${scale*f}, ${scale})`;
  }
  function resetTransform() {
    state.transform = {x:0, y:0, scale:1, flipped:false};
    applyTransform();
  }

  // --- EVENTS ---
  function bindControls() {
    // UI Interaction
    el.cats.addEventListener('change', fullRefresh);
    el.search.addEventListener('input', () => {
      // Debounce slightly or just clear queue
      state.preloadQueue = [];
      fillQueue();
    });

    // Buttons
    el.btnFwd.onclick = () => navigateForward();
    el.btnBack.onclick = navigateBack;
    document.getElementById('resetBtn').onclick = resetTransform;
    document.getElementById('flipBtn').onclick = () => { state.transform.flipped = !state.transform.flipped; applyTransform(); };
    document.getElementById('uiBtn').onclick = () => document.body.classList.toggle('hidden-ui');
    document.getElementById('copyBtn').onclick = () => { if(state.currentUrl) navigator.clipboard.writeText(state.currentUrl); };

    // Keyboard
    document.addEventListener('keydown', e => {
      if(document.activeElement === el.search) return;
      const k = e.key.toLowerCase();
      if(k==='d' || k==='arrowright') navigateForward();
      if(k==='a' || k==='arrowleft') navigateBack();
      if(k==='w') { state.transform.scale+=0.1; applyTransform(); }
      if(k==='s') { state.transform.scale=Math.max(0.1, state.transform.scale-0.1); applyTransform(); }
      if(k==='r') resetTransform();
      if(k==='f') { state.transform.flipped = !state.transform.flipped; applyTransform(); }
      if(k==='u') document.body.classList.toggle('hidden-ui');
    });

    // Dragging (Mouse + Touch)
    const startDrag = (x,y) => {
      state.isDragging = true;
      state.dragStart = { x: x - state.transform.x, y: y - state.transform.y };
      el.img.style.cursor = 'grabbing';
    };
    const doDrag = (x,y) => {
      if(!state.isDragging) return;
      state.transform.x = x - state.dragStart.x;
      state.transform.y = y - state.dragStart.y;
      requestAnimationFrame(applyTransform);
    };
    const endDrag = () => { state.isDragging = false; el.img.style.cursor = 'grab'; };

    el.img.addEventListener('mousedown', e => { e.preventDefault(); startDrag(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => doDrag(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);
    
    el.img.addEventListener('touchstart', e => { if(e.touches.length===1) startDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    window.addEventListener('touchmove', e => { if(e.touches.length===1) doDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    window.addEventListener('touchend', endDrag);
  }

  init();
</script>
</body>
</html>
