<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Ref Navigator - Dual Mode</title>
  <style>
    :root { --bg: #000; --ui-bg: rgba(20,20,20,0.9); --accent: #4a90e2; }
    body { margin: 0; background: var(--bg); color: #fff; font-family: system-ui, sans-serif; height: 100vh; width: 100vw; overflow: hidden; display: flex; }
    
    /* Layout */
    .instance { position: relative; flex: 1; height: 100vh; border-right: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; }
    .instance:last-child { border-right: none; }

    .viewport { flex: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; background: #050505; }
    .mainImage { max-width: 100%; max-height: 100%; object-fit: contain; will-change: transform; transition: opacity 0.2s; cursor: grab; }
    
    /* UI Layers */
    .ui-layer { position: absolute; z-index: 100; pointer-events: none; width: 100%; }
    .ui-layer > * { pointer-events: auto; }

    .top-bar { top: 10px; display: flex; justify-content: center; }
    .category-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 2px; background: var(--ui-bg); padding: 4px; border-radius: 8px; border: 1px solid #444; max-width: 90%; }
    
    .cat-btn { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; background: #222; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: bold; color: #666; }
    .cat-btn input { display: none; }
    .cat-btn:has(input:checked) { background: var(--accent); color: #fff; }

    .loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--ui-bg); padding: 8px 16px; border-radius: 6px; border: 1px solid var(--accent); display: none; z-index: 1000; font-size: 10px; letter-spacing: 1px; }

    /* Global UI (Hotkeys notice) */
    #global-hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 10px; color: #555; pointer-events: none; z-index: 200; }
    
    .hidden-ui .ui-layer { display: none !important; }
  </style>
</head>
<body>

<div id="global-hint">A/D: Nav | W/S: Zoom | R: Reset | F: Flip | U: Hide UI</div>

<div class="instance" id="inst1">
    <div class="ui-layer top-bar">
        <div class="category-container cat-wrapper"></div>
    </div>
    <div class="viewport">
        <img class="mainImage" draggable="false" />
        <div class="loader">SNIPING...</div>
    </div>
</div>

<div class="instance" id="inst2">
    <div class="ui-layer top-bar">
        <div class="category-container cat-wrapper"></div>
    </div>
    <div class="viewport">
        <img class="mainImage" draggable="false" />
        <div class="loader">SNIPING...</div>
    </div>
</div>

<script>
  const baseURL = 'https://f003.backblazeb2.com/file/linksref2/';
  const categories = [
    {v:"People",l:"P"},{v:"pplus",l:"p"},{v:"Anime",l:"A"},{v:"angle",l:"a"},{v:"Figure",l:"F"},{v:"Style",l:"S"},
    {v:"XMaleAnatomy",l:"X"},{v:"Emotions",l:"E"},{v:"Background",l:"B"},{v:"Walk",l:"W"},{v:"screencap",l:"s"},{v:"Manga",l:"M"},
    {v:"moeManga",l:"m"},{v:"TestPanel",l:"T"}
  ];

  class RefInstance {
    constructor(containerId, defaultCatIndex) {
      this.container = document.getElementById(containerId);
      this.img = this.container.querySelector('.mainImage');
      this.catWrapper = this.container.querySelector('.cat-wrapper');
      this.loader = this.container.querySelector('.loader');
      
      this.state = {
        history: [],
        index: -1,
        prefetched: null,
        transform: { x:0, y:0, scale:1, flipped:false },
        isDragging: false,
        dragStart: { x:0, y:0 },
        minSize: 250
      };

      this.init(defaultCatIndex);
    }

    init(defaultCatIndex) {
      categories.forEach((cat, idx) => {
        const label = document.createElement('label');
        label.className = 'cat-btn';
        label.innerHTML = `<input type="checkbox" value="${cat.v}" ${idx === defaultCatIndex ? 'checked' : ''}>${cat.l}`;
        this.catWrapper.appendChild(label);
      });

      this.bindMouse();
      this.catWrapper.onchange = () => {
        this.state.history = [];
        this.state.index = -1;
        this.navigateForward();
      };
    }

    async getFileSize(cat) {
      try {
        const resp = await fetch(baseURL + cat + '.txt', { method: 'HEAD' });
        return parseInt(resp.headers.get('content-length')) || 100000;
      } catch(e) { return 100000; }
    }

    async sniperFetch(retry = 0) {
      if (retry > 5) return null;
      const active = [...this.catWrapper.querySelectorAll('input:checked')].map(i => i.value);
      if (!active.length) return null;
      
      const cat = active[Math.floor(Math.random() * active.length)];
      const totalSize = await this.getFileSize(cat);
      const randomPos = Math.floor(Math.random() * (totalSize - 3000));
      
      try {
        const resp = await fetch(baseURL + cat + '.txt', {
          headers: { 'Range': `bytes=${randomPos}-${randomPos + 2500}` }
        });
        const chunk = await resp.text();
        const validLines = chunk.split('\n').slice(1, -1).filter(l => l.length > 10);
        if (!validLines.length) return this.sniperFetch(retry + 1);

        const url = validLines[Math.floor(Math.random() * validLines.length)].trim();
        const isGood = await this.validateSize(url);
        return isGood ? url : this.sniperFetch(retry + 1);
      } catch (e) { return this.sniperFetch(retry + 1); }
    }

    validateSize(url) {
      return new Promise(res => {
        const i = new Image();
        i.onload = () => res(i.naturalWidth >= this.state.minSize);
        i.onerror = () => res(false);
        i.src = url;
      });
    }

    async navigateForward() {
      if (this.state.index < this.state.history.length - 1) {
        this.state.index++;
        this.displayImage(this.state.history[this.state.index]);
        return;
      }
      this.loader.style.display = 'block';
      let url = this.state.prefetched || await this.sniperFetch();
      this.state.prefetched = null;
      if (url) {
        this.state.history.push(url);
        this.state.index = this.state.history.length - 1;
        this.displayImage(url);
      }
    }

    navigateBack() {
      if (this.state.index > 0) {
        this.state.index--;
        this.displayImage(this.state.history[this.state.index]);
      }
    }

    displayImage(url) {
      this.img.style.opacity = '0.3';
      this.loader.style.display = 'block';
      const temp = new Image();
      temp.onload = () => {
        this.img.src = url;
        this.img.style.opacity = '1';
        this.loader.style.display = 'none';
        this.resetTransform();
        this.prepareNext();
      };
      temp.src = url;
    }

    async prepareNext() { this.state.prefetched = await this.sniperFetch(); }

    applyTransform() {
      const {x, y, scale, flipped} = this.state.transform;
      this.img.style.transform = `translate(${x}px, ${y}px) scale(${scale * (flipped ? -1 : 1)}, ${scale})`;
    }

    resetTransform() {
      this.state.transform = { x:0, y:0, scale:1, flipped:false };
      this.applyTransform();
    }

    bindMouse() {
      const start = (x, y) => { this.state.isDragging = true; this.state.dragStart = { x: x - this.state.transform.x, y: y - this.state.transform.y }; };
      const move = (x, y) => { if (this.state.isDragging) { this.state.transform.x = x - this.state.dragStart.x; this.state.transform.y = y - this.state.dragStart.y; this.applyTransform(); } };
      this.img.onmousedown = e => start(e.clientX, e.clientY);
      this.container.onmousemove = e => move(e.clientX, e.clientY);
      window.addEventListener('mouseup', () => this.state.isDragging = false);
    }
  }

  // Initialize both instances
  const instances = [
    new RefInstance('inst1', 0), // Default to People
    new RefInstance('inst2', 2)  // Default to Anime
  ];

  // Load initial images
  instances.forEach(i => i.navigateForward());

  // Unified Hotkeys
  document.onkeydown = (e) => {
    const k = e.key.toLowerCase();
    instances.forEach(inst => {
        if (k === 'd' || k === 'arrowright') inst.navigateForward();
        if (k === 'a' || k === 'arrowleft') inst.navigateBack();
        if (k === 'w') { inst.state.transform.scale += 0.2; inst.applyTransform(); }
        if (k === 's') { inst.state.transform.scale = Math.max(0.1, inst.state.transform.scale - 0.2); inst.applyTransform(); }
        if (k === 'f') { inst.state.transform.flipped = !inst.state.transform.flipped; inst.applyTransform(); }
        if (k === 'r') inst.resetTransform();
    });
    if (k === 'u') document.body.classList.toggle('hidden-ui');
  };
</script>
</body>
</html>
